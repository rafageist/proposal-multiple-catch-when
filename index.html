<h1 id="ecmascript-multiple-and-conditional-catch-blocks-with-new-when-keyword">ECMAScript Multiple and conditional &quot;catch&quot; blocks with new &quot;when&quot; keyword</h1>
<h2 id="introduction">Introduction</h2>
<p>JavaScript’s <code>try-catch</code> structure is a powerful tool for error handling, but it can be improved to offer more flexibility and clarity. Unlike statically-typed languages, JavaScript does not allow developers to specify the type of the error caught in a <code>catch</code> block. This limitation can lead to unnecessary complexity and less precise error handling. This proposal introduces the ability to have multiple <code>catch</code> blocks, each with a <code>when</code> clause, allowing developers to apply specific conditions to each <code>catch</code> block. This enhancement provides a more controlled and expressive approach to managing different types of exceptions.</p>
<h2 id="motivation">Motivation</h2>
<h3 id="learning-from-csharp">Learning from CSharp</h3>
<p>In languages like C#, the <code>when</code> keyword is used within <code>catch</code> blocks to add conditions that must be true for the block to execute (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/when">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/when</a>). This allows for more precise error handling without the need for nested <code>if</code> statements, making code cleaner and more maintainable. By introducing a similar <code>when</code> clause to JavaScript, this proposal aims to bring the same level of control and clarity to JavaScript’s error handling.</p>
<h3 id="addressing-javascript-s-limitations">Addressing JavaScript’s Limitations</h3>
<p>JavaScript currently lacks the ability to type the error variable in a <code>catch</code> block, often leading to less precise error handling. Developers must write additional conditional logic within <code>catch</code> blocks to check the type of the error or other conditions, which can make the code harder to read and maintain. The <code>when</code> clause offers a solution by allowing developers to filter errors directly within the <code>catch</code> statement, reducing the need for nested conditions and making the intention of the error handling code clearer.</p>
<h3 id="why-when-">Why <code>when</code>?</h3>
<p>The <code>when</code> clause allows developers to conditionally handle exceptions based on custom logic, similar to type-specific <code>catch</code> blocks in statically-typed languages. This makes the error-handling code more readable, maintainable, and specific.</p>
<h3 id="compatibility">Compatibility</h3>
<p>This proposal is designed to be both backward and forward compatible:</p>
<ul>
<li><p><strong>Backward Compatibility</strong>: The <code>when</code> clause is an optional addition and does not affect existing JavaScript code. Without the <code>when</code> clause, the <code>try-catch</code> structure functions as it currently does.</p>
</li>
<li><p><strong>Forward Compatibility</strong>: If JavaScript or TypeScript introduces typed <code>catch</code> variables in the future, the <code>when</code> clause will remain relevant and useful, providing an additional layer of conditional logic that works alongside any future typing features.</p>
</li>
</ul>
<h2 id="syntax">Syntax</h2>
<p>The proposed syntax introduces the <code>when</code> clause within <code>catch</code> blocks, enabling developers to specify conditions directly:</p>
<pre><code class="lang-plaintext"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// Code that may throw an exception </span>
}  
<span class="hljs-keyword">catch</span> (&lt;<span class="hljs-keyword">error</span> variable <span class="hljs-number">1</span>&gt;) when (&lt;<span class="hljs-keyword">boolean</span> expression <span class="hljs-number">1</span>&gt;) {   
  <span class="hljs-comment">// Handle error</span>
}  
<span class="hljs-keyword">catch</span> (&lt;<span class="hljs-keyword">error</span> variable <span class="hljs-number">2</span>&gt;) when (&lt;<span class="hljs-keyword">boolean</span> expression <span class="hljs-number">2</span>&gt;) {
  <span class="hljs-comment">// Handle error</span>
}  
<span class="hljs-keyword">finally</span> {   
  <span class="hljs-comment">// Code that always runs </span>
}
</code></pre>
<h2 id="example">Example</h2>
<p>Here’s a practical example:</p>
<pre><code class="lang-plaintext"><span class="hljs-keyword">try</span> {
  data = fetchData();
} 
<span class="hljs-keyword">catch</span> (err) <span class="hljs-keyword">when</span> (err <span class="hljs-keyword">instanceof</span> NetworkError) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Network error:'</span>, err.message);
} 
<span class="hljs-keyword">catch</span> (err) <span class="hljs-keyword">when</span> (err <span class="hljs-keyword">instanceof</span> SyntaxError) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Syntax error in response:'</span>, err.message);
} 
<span class="hljs-keyword">finally</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Cleanup code, executed regardless of success or failure.'</span>);
}
</code></pre>
<h2 id="benefits">Benefits</h2>
<ul>
<li><strong>Precision</strong>: Handle specific error types or conditions more effectively.</li>
<li><strong>Clarity</strong>: The <code>when</code> clause makes it clear which errors are being handled and under what conditions.</li>
<li><strong>Simplicity</strong>: Reduces the need for complex nested conditions within <code>catch</code> blocks.</li>
<li><strong>Expressiveness</strong>: Provides a more powerful way to handle different error scenarios in a single <code>try-catch</code> statement.</li>
</ul>
<h2 id="considerations">Considerations</h2>
<ul>
<li><strong>Performance</strong>: Optimizations may be needed to minimize any potential performance impact from introducing multiple <code>catch</code> blocks with conditions.</li>
<li><strong>Tooling</strong>: Updates to linters, transpilers, and other tools may be necessary to support the new syntax.</li>
</ul>
<h2 id="current-workarounds-in-javascript">Current Workarounds in JavaScript</h2>
<h3 id="using-if-else-statements">Using <code>if-else</code> Statements</h3>
<p>One common approach to handling multiple error types within a single <code>catch</code> block is to use <code>if-else</code> statements to check the type or other properties of the caught error. Although this method is straightforward, it can lead to less readable and more cluttered code when handling many different error types.</p>
<pre><code class="lang-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Code that may throw an exception</span>
} <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'TypeError occurred:'</span>, err.message);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'ReferenceError occurred:'</span>, err.message);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err.message.includes(<span class="hljs-string">'custom message'</span>)) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Custom error detected:'</span>, err.message);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unhandled error:'</span>, err.message);
    }
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Cleanup code, executed regardless of success or failure.'</span>);
}
</code></pre>
<h3 id="using-switch-true-">Using <code>switch(true)</code></h3>
<p>As an alternative to multiple <code>if-else</code> statements, a <code>switch(true)</code> structure can be used to organize the error handling code. This approach can make the code more readable and maintainable by reducing the repetitive nature of <code>if</code> conditions and by clearly segregating the handling logic for different error conditions.</p>
<pre><code class="lang-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Code that may throw an exception</span>
} <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">case</span> err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>:
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'TypeError occurred:'</span>, err.message);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>:
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'ReferenceError occurred:'</span>, err.message);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> err.message.includes(<span class="hljs-string">'custom message'</span>):
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Custom error detected:'</span>, err.message);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unhandled error:'</span>, err.message);
    }
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Cleanup code, executed regardless of success or failure.'</span>);
}
</code></pre>
<h2 id="adding-when-keyword-for-conditional-catch-blocks-in-ecmascript">Adding <code>when</code> Keyword for Conditional Catch Blocks in ECMAScript</h2>
<p>This proposal suggests modifications to the ECMAScript specification, specifically to section 14.15 (<a href="https://tc39.es/ecma262/#sec-try-statement">https://tc39.es/ecma262/#sec-try-statement</a>), to introduce the <code>when</code> keyword for conditional <code>catch</code> blocks. This would allow more granular and conditional error handling in JavaScript, improving the language&#39;s robustness and clarity.</p>
<p>This modification introduces the <code>when</code> keyword for conditional <code>catch</code> blocks in JavaScript, allowing developers to handle specific exceptions based on conditions directly within the <code>catch</code> block. This enhancement brings JavaScript closer to the error-handling flexibility found in languages like C# while maintaining backward and forward compatibility with existing and future language features.</p>
<pre><code class="lang-plaintext"><span class="hljs-number">14.15</span> The <span class="hljs-keyword">try</span> Statement (Modified)

Syntax (Proposed Change)

TryStatement[Yield, Await, <span class="hljs-keyword">Return</span>] :
    <span class="hljs-keyword">try</span> Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>] CatchSequence[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    <span class="hljs-keyword">try</span> Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>] <span class="hljs-keyword">Finally</span>[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    <span class="hljs-keyword">try</span> Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>] CatchSequence[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>] <span class="hljs-keyword">Finally</span>[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]

CatchSequence[Yield, Await, <span class="hljs-keyword">Return</span>] :
    <span class="hljs-keyword">Catch</span>[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    CatchSequence[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>] <span class="hljs-keyword">Catch</span>[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]

<span class="hljs-keyword">Catch</span>[Yield, Await, <span class="hljs-keyword">Return</span>] :
    <span class="hljs-keyword">catch</span> ( CatchParameter[?Yield, ?Await] ) <span class="hljs-keyword">when</span> ( Expression ) Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    <span class="hljs-keyword">catch</span> <span class="hljs-keyword">when</span> ( Expression ) Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    <span class="hljs-keyword">catch</span> ( CatchParameter[?Yield, ?Await] ) Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]
    <span class="hljs-keyword">catch</span> Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]

<span class="hljs-keyword">Finally</span>[Yield, Await, <span class="hljs-keyword">Return</span>] :
    <span class="hljs-keyword">finally</span> Block[?Yield, ?Await, ?<span class="hljs-keyword">Return</span>]

CatchParameter[Yield, Await] :
    BindingIdentifier[?Yield, ?Await]
    BindingPattern[?Yield, ?Await]

<span class="hljs-number">14.15</span><span class="hljs-number">.1</span> <span class="hljs-keyword">Static</span> Semantics: Early Errors (Proposed Change)

(...)

<span class="hljs-keyword">Catch</span> : <span class="hljs-keyword">catch</span> ( CatchParameter ) <span class="hljs-keyword">when</span> ( Expression ) Block

- It <span class="hljs-keyword">is</span> a Syntax <span class="hljs-keyword">Error</span> <span class="hljs-keyword">if</span> BoundNames <span class="hljs-keyword">of</span> CatchParameter contains any duplicate elements.
- It <span class="hljs-keyword">is</span> a Syntax <span class="hljs-keyword">Error</span> <span class="hljs-keyword">if</span> any element <span class="hljs-keyword">of</span> the BoundNames <span class="hljs-keyword">of</span> CatchParameter also occurs <span class="hljs-keyword">in</span> the LexicallyDeclaredNames <span class="hljs-keyword">of</span> Block.
- It <span class="hljs-keyword">is</span> a Syntax <span class="hljs-keyword">Error</span> <span class="hljs-keyword">if</span> any element <span class="hljs-keyword">of</span> the BoundNames <span class="hljs-keyword">of</span> CatchParameter also occurs <span class="hljs-keyword">in</span> the VarDeclaredNames <span class="hljs-keyword">of</span> Block.
- It <span class="hljs-keyword">is</span> a Syntax <span class="hljs-keyword">Error</span> <span class="hljs-keyword">if</span> the Expression <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a valid <span class="hljs-built_in">Boolean</span> expression.

<span class="hljs-number">14.15</span><span class="hljs-number">.2</span> Runtime Semantics: CatchClauseEvaluation (Proposed Change)

(...)

<span class="hljs-keyword">Catch</span> : <span class="hljs-keyword">catch</span> ( CatchParameter ) <span class="hljs-keyword">when</span> ( Expression ) Block

<span class="hljs-number">1.</span> <span class="hljs-keyword">Let</span> oldEnv be the running execution context<span class="hljs-comment">'s LexicalEnvironment.</span>
<span class="hljs-number">2.</span> <span class="hljs-keyword">Let</span> catchEnv be NewDeclarativeEnvironment(oldEnv).
<span class="hljs-number">3.</span> <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> element argName <span class="hljs-keyword">of</span> the BoundNames <span class="hljs-keyword">of</span> CatchParameter, <span class="hljs-keyword">do</span>
   a. Perform ! catchEnv.CreateMutableBinding(argName, <span class="hljs-literal">false</span>).
<span class="hljs-number">4.</span> <span class="hljs-keyword">Set</span> the running execution context<span class="hljs-comment">'s LexicalEnvironment to catchEnv.</span>
<span class="hljs-number">5.</span> <span class="hljs-keyword">Let</span> status be Completion(BindingInitialization <span class="hljs-keyword">of</span> CatchParameter <span class="hljs-keyword">with</span> arguments thrownValue <span class="hljs-keyword">and</span> catchEnv).
<span class="hljs-number">6.</span> <span class="hljs-keyword">If</span> status <span class="hljs-keyword">is</span> an abrupt completion, <span class="hljs-keyword">then</span>
   a. <span class="hljs-keyword">Set</span> the running execution context<span class="hljs-comment">'s LexicalEnvironment to oldEnv.</span>
   b. <span class="hljs-keyword">Return</span> ? status.
<span class="hljs-number">7.</span> <span class="hljs-keyword">If</span> the result <span class="hljs-keyword">of</span> evaluating Expression <span class="hljs-keyword">is</span> <span class="hljs-literal">false</span>, <span class="hljs-keyword">return</span> undefined.
<span class="hljs-number">8.</span> <span class="hljs-keyword">Let</span> B be Completion(Evaluation <span class="hljs-keyword">of</span> Block).
<span class="hljs-number">9.</span> <span class="hljs-keyword">Set</span> the running execution context<span class="hljs-comment">'s LexicalEnvironment to oldEnv.</span>
<span class="hljs-number">10.</span> <span class="hljs-keyword">Return</span> ? B.

(...)

<span class="hljs-number">14.15</span><span class="hljs-number">.3</span> Runtime Semantics: Evaluation (Proposed Change)

(...)

TryStatement : <span class="hljs-keyword">try</span> Block CatchSequence <span class="hljs-keyword">Finally</span>

<span class="hljs-number">1.</span> <span class="hljs-keyword">Let</span> B be Completion(Evaluation <span class="hljs-keyword">of</span> Block).
<span class="hljs-number">2.</span> <span class="hljs-keyword">Let</span> S be the List <span class="hljs-keyword">of</span> CaseClause items <span class="hljs-keyword">in</span> CatchSequence, <span class="hljs-keyword">in</span> source <span class="hljs-keyword">text</span> <span class="hljs-keyword">order</span>.
<span class="hljs-number">2.</span> <span class="hljs-keyword">If</span> B <span class="hljs-keyword">is</span> a <span class="hljs-keyword">throw</span> completion, <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> CatchClause A <span class="hljs-keyword">of</span> S, <span class="hljs-keyword">do</span>:
   a. <span class="hljs-keyword">Let</span> C be Completion(CatchClauseEvaluation <span class="hljs-keyword">of</span> CatchClause <span class="hljs-keyword">with</span> argument B.[[Value]]).
   b. <span class="hljs-keyword">If</span> C <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> undefined, <span class="hljs-keyword">exit</span> the <span class="hljs-keyword">loop</span> <span class="hljs-keyword">and</span> proceed <span class="hljs-keyword">to</span> the <span class="hljs-keyword">next</span> <span class="hljs-keyword">step</span>.
<span class="hljs-number">3.</span> <span class="hljs-keyword">If</span> all <span class="hljs-keyword">Catch</span> <span class="hljs-keyword">of</span> CatchSequence result <span class="hljs-keyword">in</span> undefined, rethrow the exception.
<span class="hljs-number">4.</span> Otherwise, <span class="hljs-keyword">let</span> C be B.
<span class="hljs-number">5.</span> <span class="hljs-keyword">Let</span> F be Completion(Evaluation <span class="hljs-keyword">of</span> <span class="hljs-keyword">Finally</span>).
<span class="hljs-number">6.</span> <span class="hljs-keyword">If</span> F <span class="hljs-keyword">is</span> a normal completion, <span class="hljs-keyword">set</span> F <span class="hljs-keyword">to</span> C.
<span class="hljs-number">7.</span> <span class="hljs-keyword">Return</span> ? UpdateEmpty(F, undefined).
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Enhancing JavaScript’s error handling with multiple <code>catch</code> blocks and a <code>when</code> clause offers a natural and powerful way to manage exceptions. This proposal builds on the existing <code>try-catch</code> structure, providing developers with more control and flexibility while maintaining code clarity.</p>
<h2 id="further-discussion">Further Discussion</h2>
<p>We invite feedback and suggestions from the community to refine and improve this proposal.</p>
